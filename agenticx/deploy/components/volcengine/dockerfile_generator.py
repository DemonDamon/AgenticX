#!/usr/bin/env python3
"""
AgentKit Dockerfile Generator

Generates Dockerfiles for deploying AgenticX Agents to Volcengine AgentKit platform.
Aligned with upstream toolkit/resources/templates/python/Dockerfile.j2 but uses
Python string.Template instead of Jinja2 to avoid new dependencies.

Author: Damon Li
"""

import logging
from typing import Dict, Optional, List
from pathlib import Path
from string import Template

logger = logging.getLogger(__name__)

# Default base image pattern (aligned with upstream Dockerfile.j2)
DEFAULT_BASE_IMAGE_PATTERN = (
    "agentkit-prod-public-cn-beijing.cr.volces.com/base/"
    "py-simple:python{python_version}-bookworm-slim-latest"
)

# Dockerfile template (aligned with upstream Dockerfile.j2)
DOCKERFILE_TEMPLATE = Template("""\
# Dockerfile generated by AgenticX VolcEngine Deploy Adapter
# Aligned with AgentKit Dockerfile template
${base_image_line}

ENV UV_SYSTEM_PYTHON=1 UV_COMPILE_BYTECODE=1 PYTHONUNBUFFERED=1 DOCKER_CONTAINER=1

${extra_env_lines}
# Install dependencies
${dependencies_section}

EXPOSE 8000

WORKDIR /app

# Copy project files
COPY . .

CMD ["python", "-m", "${entry_point}"]
""")


def generate_dockerfile(
    entry_point: str = "wrapper",
    python_version: str = "3.12",
    base_image: Optional[str] = None,
    dependencies_file: str = "requirements.txt",
    extra_envs: Optional[Dict[str, str]] = None,
    build_script: Optional[str] = None,
) -> str:
    """
    Generate Dockerfile content for AgentKit deployment.

    Aligns with upstream toolkit/resources/templates/python/Dockerfile.j2
    but uses string.Template for simplicity.

    Args:
        entry_point: Python module path for CMD (e.g., "wrapper")
        python_version: Python version (e.g., "3.12", "3.11")
        base_image: Custom base Docker image. If None, uses AgentKit default.
        dependencies_file: Path to requirements file (e.g., "requirements.txt")
        extra_envs: Additional environment variables to set
        build_script: Optional build script to run during image build

    Returns:
        Dockerfile content as a string

    Raises:
        ValueError: If entry_point is empty
    """
    if not entry_point or not entry_point.strip():
        raise ValueError("entry_point cannot be empty")

    # Determine base image
    if base_image:
        base_image_line = f"FROM {base_image}"
    else:
        default_image = DEFAULT_BASE_IMAGE_PATTERN.format(
            python_version=python_version
        )
        base_image_line = f"FROM {default_image}"

    # Build extra ENV lines
    extra_envs = extra_envs or {}
    if extra_envs:
        env_parts = [f"ENV {k}={v}" for k, v in extra_envs.items()]
        extra_env_lines = "\n".join(env_parts) + "\n"
    else:
        extra_env_lines = ""

    # Build dependencies section
    deps_lines = []
    if dependencies_file:
        deps_lines.append(f"COPY {dependencies_file} {dependencies_file}")
        deps_lines.append(f"RUN uv pip install -r {dependencies_file}")

    if build_script:
        deps_lines.append(f"COPY {build_script} /tmp/build_script.sh")
        deps_lines.append(
            "RUN chmod +x /tmp/build_script.sh && /tmp/build_script.sh "
            "&& rm /tmp/build_script.sh"
        )

    dependencies_section = "\n".join(deps_lines) if deps_lines else "# No dependencies"

    # Render template
    content = DOCKERFILE_TEMPLATE.substitute(
        base_image_line=base_image_line,
        extra_env_lines=extra_env_lines,
        dependencies_section=dependencies_section,
        entry_point=entry_point.strip(),
    )

    return content


def save_dockerfile(content: str, output_path: str) -> Path:
    """
    Save Dockerfile content to file.

    Args:
        content: Dockerfile content string
        output_path: Path to write the Dockerfile

    Returns:
        Path object of the written file
    """
    output_path = Path(output_path)

    # Ensure parent directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(content)

    logger.info(f"Generated Dockerfile: {output_path}")
    return output_path


def generate_requirements(
    extra_deps: Optional[List[str]] = None,
    agenticx_version: Optional[str] = None,
) -> str:
    """
    Generate requirements.txt content including agenticx dependency.

    Args:
        extra_deps: Additional pip dependencies to include
        agenticx_version: Specific agenticx version pin (e.g., ">=0.1.0")

    Returns:
        requirements.txt content as a string
    """
    deps = []

    # Always include agenticx
    if agenticx_version:
        deps.append(f"agenticx{agenticx_version}")
    else:
        deps.append("agenticx")

    # Add extra dependencies
    if extra_deps:
        deps.extend(extra_deps)

    return "\n".join(deps) + "\n"
